<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three Body Problem</title>
    <link rel="stylesheet" href="../app-theme.css">
    <style>
        :root {
            --color-body1: #e74c3c;
            --color-body2: #3498db;
            --color-body3: #2ecc71;
            --color-trail1: rgba(231, 76, 60, 0.6);
            --color-trail2: rgba(52, 152, 219, 0.6);
            --color-trail3: rgba(46, 204, 113, 0.6);
        }

        .container {
            display: grid;
            grid-template-columns: 280px 1fr;
            grid-template-rows: auto 1fr;
            gap: 15px;
            padding: 15px;
            max-width: 1400px;
            margin: 0 auto;
            min-height: 100vh;
        }

        .controls {
            background: white;
            border-radius: var(--border-radius);
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            max-height: calc(100vh - 100px);
        }

        .controls h3 {
            font-size: 14px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--color-border-light);
            color: #000;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 5px;
            color: #000;
        }

        .control-group label span {
            font-weight: bold;
            color: #000;
        }

        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background 0.2s;
        }

        button.primary {
            background: var(--color-primary);
            color: white;
        }

        button.primary:hover {
            background: #2980b9;
        }

        button.danger {
            background: #e74c3c;
            color: white;
        }

        button.danger:hover {
            background: #c0392b;
        }

        button.preset {
            background: #e8e0ed;
            color: #333;
            font-size: 11px;
            padding: 8px;
            min-width: 45%;
        }

        button.preset:hover {
            background: #d4c4de;
        }

        .stats {
            background: #f5f5f5;
            border-radius: 4px;
            padding: 10px;
            font-size: 11px;
            font-family: ui-monospace, monospace;
        }

        .stats div {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .stats .label {
            color: #000;
        }

        .stats .value {
            color: #000;
        }

        .main {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1.5fr 1fr;
            gap: 15px;
        }

        .panel {
            background: #2a2a2a;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 10px 15px;
            font-size: 13px;
            font-weight: 600;
            border-bottom: 1px solid #444;
            background: #2a2a2a;
            color: #ccc;
        }

        .panel-content {
            flex: 1;
            position: relative;
        }

        .panel canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .simulation-panel {
            grid-column: 1 / -1;
        }

        .legend {
            display: flex;
            gap: 15px;
            padding: 8px 15px;
            font-size: 11px;
            border-top: 1px solid #444;
            background: #2a2a2a;
            color: #ccc;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .color-body1 { background: var(--color-body1); }
        .color-body2 { background: var(--color-body2); }
        .color-body3 { background: var(--color-body3); }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .checkbox-group label {
            font-size: 12px;
            color: #000;
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
            .main {
                grid-template-columns: 1fr;
                grid-template-rows: 400px repeat(2, 200px);
            }
            .simulation-panel {
                grid-column: 1;
            }
            .controls {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <header class="app-header">
        <div class="header-left">
            <h1>Three Body Problem</h1>
            <span class="subtitle">Gravitational chaos simulation</span>
        </div>
        <nav>
            <a href="https://marhar.github.io/">Home</a>
            <a href="https://github.com/marhar/marhar.github.io/tree/master/apps/three-body">Source</a>
        </nav>
    </header>

    <div class="container">

        <aside class="controls">
            <h3>Simulation</h3>

            <div class="control-group">
                <label>Time Step <span id="dt-val">0.001</span></label>
                <input type="range" id="dt" min="0.0001" max="0.01" step="0.0001" value="0.001">
            </div>

            <div class="control-group">
                <label>Speed <span id="speed-val">1.0</span>x</label>
                <input type="range" id="speed" min="0.1" max="5" step="0.1" value="1">
            </div>

            <div class="control-group">
                <label>Trail Length <span id="trail-val">500</span></label>
                <input type="range" id="trail" min="100" max="2000" step="100" value="500">
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="show-trails" checked>
                <label for="show-trails">Show Trails</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="show-vectors">
                <label for="show-vectors">Show Velocity Vectors</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="center-mass">
                <label for="center-mass">Center on Center of Mass</label>
            </div>

            <div class="button-group">
                <button class="primary" id="start-btn">Start</button>
                <button class="danger" id="reset-btn">Reset</button>
            </div>

            <h3>Presets</h3>
            <div class="button-group">
                <button class="preset" id="preset-figure8">Figure-8</button>
                <button class="preset" id="preset-lagrange">Lagrange</button>
                <button class="preset" id="preset-binary">Binary + Moon</button>
                <button class="preset" id="preset-chaos">Chaos</button>
            </div>

            <h3>Body Masses</h3>
            <div class="control-group">
                <label>Mass 1 <span id="m1-val" style="color: var(--color-body1);">1.0</span></label>
                <input type="range" id="m1" min="0.1" max="5" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>Mass 2 <span id="m2-val" style="color: var(--color-body2);">1.0</span></label>
                <input type="range" id="m2" min="0.1" max="5" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>Mass 3 <span id="m3-val" style="color: var(--color-body3);">1.0</span></label>
                <input type="range" id="m3" min="0.1" max="5" step="0.1" value="1">
            </div>

            <h3>Statistics</h3>
            <div class="stats">
                <div><span class="label">Time:</span> <span id="stat-time" class="value">0.00</span></div>
                <div><span class="label">Kinetic Energy:</span> <span id="stat-ke" class="value">0.00</span></div>
                <div><span class="label">Potential Energy:</span> <span id="stat-pe" class="value">0.00</span></div>
                <div><span class="label">Total Energy:</span> <span id="stat-total" class="value">0.00</span></div>
                <div><span class="label">Momentum (x,y):</span> <span id="stat-momentum" class="value">0, 0</span></div>
            </div>
        </aside>

        <main class="main">
            <div class="panel simulation-panel">
                <div class="panel-header">Orbital Simulation</div>
                <div class="panel-content">
                    <canvas id="sim-canvas"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color color-body1"></div> Body 1</div>
                    <div class="legend-item"><div class="legend-color color-body2"></div> Body 2</div>
                    <div class="legend-item"><div class="legend-color color-body3"></div> Body 3</div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header">Energy vs Time</div>
                <div class="panel-content">
                    <canvas id="energy-canvas"></canvas>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header">Distance Between Bodies</div>
                <div class="panel-content">
                    <canvas id="distance-canvas"></canvas>
                </div>
            </div>
        </main>
    </div>

    <script>
    (function() {
        'use strict';

        // ============================================================
        // Constants
        // ============================================================

        const G = 1;  // Gravitational constant (normalized units)
        const SOFTENING = 0.01;  // Softening parameter to prevent singularities
        const GRAPH_HISTORY = 500;

        const COLORS = {
            body1: '#e74c3c',
            body2: '#3498db',
            body3: '#2ecc71',
            trail1: 'rgba(231, 76, 60, 0.5)',
            trail2: 'rgba(52, 152, 219, 0.5)',
            trail3: 'rgba(46, 204, 113, 0.5)',
            grid: '#444',
            label: '#999',
            canvasBg: '#1a1a2e',
            graphBg: '#252525',
            ke: '#e74c3c',
            pe: '#3498db',
            total: '#2ecc71'
        };

        // ============================================================
        // State
        // ============================================================

        let params = {
            dt: 0.001,
            speed: 1,
            trailLength: 500,
            showTrails: true,
            showVectors: false,
            centerMass: false
        };

        // Each body has: x, y, vx, vy, m
        let bodies = [];
        let initialBodies = [];

        let time = 0;
        let running = false;
        let animationId = null;

        let trails = [[], [], []];
        let energyHistory = [];
        let distanceHistory = [];

        // ============================================================
        // DOM Elements
        // ============================================================

        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');

        const simCanvas = document.getElementById('sim-canvas');
        const energyCanvas = document.getElementById('energy-canvas');
        const distanceCanvas = document.getElementById('distance-canvas');

        const simCtx = simCanvas.getContext('2d');
        const energyCtx = energyCanvas.getContext('2d');
        const distanceCtx = distanceCanvas.getContext('2d');

        // ============================================================
        // Presets - Famous Three Body Configurations
        // ============================================================

        const PRESETS = {
            // Figure-8 orbit discovered by Moore (1993) and Chenciner & Montgomery (2000)
            'figure8': {
                bodies: [
                    { x: -0.97000436, y: 0.24308753, vx: 0.4662036850, vy: 0.4323657300, m: 1 },
                    { x: 0.97000436, y: -0.24308753, vx: 0.4662036850, vy: 0.4323657300, m: 1 },
                    { x: 0, y: 0, vx: -0.93240737, vy: -0.86473146, m: 1 }
                ],
                dt: 0.001
            },
            // Lagrange equilateral triangle (stable with equal masses)
            'lagrange': {
                bodies: [
                    { x: 0, y: 1, vx: 0.5, vy: 0, m: 1 },
                    { x: -0.866, y: -0.5, vx: -0.25, vy: 0.433, m: 1 },
                    { x: 0.866, y: -0.5, vx: -0.25, vy: -0.433, m: 1 }
                ],
                dt: 0.001
            },
            // Binary star with a small orbiting moon
            'binary': {
                bodies: [
                    { x: -0.5, y: 0, vx: 0, vy: -0.5, m: 2 },
                    { x: 0.5, y: 0, vx: 0, vy: 0.5, m: 2 },
                    { x: 2.5, y: 0, vx: 0, vy: 0.65, m: 0.1 }
                ],
                dt: 0.001
            },
            // Chaotic configuration
            'chaos': {
                bodies: [
                    { x: -1, y: 0, vx: 0, vy: 0.5, m: 1 },
                    { x: 1, y: 0, vx: 0, vy: -0.5, m: 1 },
                    { x: 0, y: 1.5, vx: 0.3, vy: 0, m: 1 }
                ],
                dt: 0.001
            }
        };

        // ============================================================
        // Physics
        // ============================================================

        function computeAccelerations(bodies) {
            const n = bodies.length;
            const acc = bodies.map(() => ({ ax: 0, ay: 0 }));

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const dx = bodies[j].x - bodies[i].x;
                    const dy = bodies[j].y - bodies[i].y;
                    const r2 = dx * dx + dy * dy + SOFTENING * SOFTENING;
                    const r = Math.sqrt(r2);
                    const r3 = r2 * r;

                    const f = G / r3;

                    // Force on i from j
                    acc[i].ax += f * bodies[j].m * dx;
                    acc[i].ay += f * bodies[j].m * dy;

                    // Force on j from i (Newton's 3rd law)
                    acc[j].ax -= f * bodies[i].m * dx;
                    acc[j].ay -= f * bodies[i].m * dy;
                }
            }

            return acc;
        }

        // RK4 integration for the gravitational n-body problem
        function rk4Step(bodies, dt) {
            const n = bodies.length;

            // Helper to add scaled state
            function addState(base, delta, scale) {
                return base.map((b, i) => ({
                    x: b.x + delta[i].dx * scale,
                    y: b.y + delta[i].dy * scale,
                    vx: b.vx + delta[i].dvx * scale,
                    vy: b.vy + delta[i].dvy * scale,
                    m: b.m
                }));
            }

            // k1
            const acc1 = computeAccelerations(bodies);
            const k1 = bodies.map((b, i) => ({
                dx: b.vx,
                dy: b.vy,
                dvx: acc1[i].ax,
                dvy: acc1[i].ay
            }));

            // k2
            const state2 = addState(bodies, k1, dt / 2);
            const acc2 = computeAccelerations(state2);
            const k2 = state2.map((b, i) => ({
                dx: b.vx,
                dy: b.vy,
                dvx: acc2[i].ax,
                dvy: acc2[i].ay
            }));

            // k3
            const state3 = addState(bodies, k2, dt / 2);
            const acc3 = computeAccelerations(state3);
            const k3 = state3.map((b, i) => ({
                dx: b.vx,
                dy: b.vy,
                dvx: acc3[i].ax,
                dvy: acc3[i].ay
            }));

            // k4
            const state4 = addState(bodies, k3, dt);
            const acc4 = computeAccelerations(state4);
            const k4 = state4.map((b, i) => ({
                dx: b.vx,
                dy: b.vy,
                dvx: acc4[i].ax,
                dvy: acc4[i].ay
            }));

            // Combine
            return bodies.map((b, i) => ({
                x: b.x + (k1[i].dx + 2*k2[i].dx + 2*k3[i].dx + k4[i].dx) * dt / 6,
                y: b.y + (k1[i].dy + 2*k2[i].dy + 2*k3[i].dy + k4[i].dy) * dt / 6,
                vx: b.vx + (k1[i].dvx + 2*k2[i].dvx + 2*k3[i].dvx + k4[i].dvx) * dt / 6,
                vy: b.vy + (k1[i].dvy + 2*k2[i].dvy + 2*k3[i].dvy + k4[i].dvy) * dt / 6,
                m: b.m
            }));
        }

        function calculateEnergy(bodies) {
            let KE = 0;
            let PE = 0;

            for (let i = 0; i < bodies.length; i++) {
                const b = bodies[i];
                KE += 0.5 * b.m * (b.vx * b.vx + b.vy * b.vy);

                for (let j = i + 1; j < bodies.length; j++) {
                    const bj = bodies[j];
                    const dx = bj.x - b.x;
                    const dy = bj.y - b.y;
                    const r = Math.sqrt(dx * dx + dy * dy + SOFTENING * SOFTENING);
                    PE -= G * b.m * bj.m / r;
                }
            }

            return { KE, PE, total: KE + PE };
        }

        function calculateMomentum(bodies) {
            let px = 0, py = 0;
            for (const b of bodies) {
                px += b.m * b.vx;
                py += b.m * b.vy;
            }
            return { px, py };
        }

        function calculateCenterOfMass(bodies) {
            let totalMass = 0;
            let cx = 0, cy = 0;
            for (const b of bodies) {
                totalMass += b.m;
                cx += b.m * b.x;
                cy += b.m * b.y;
            }
            return { x: cx / totalMass, y: cy / totalMass };
        }

        function calculateDistances(bodies) {
            return {
                d12: Math.sqrt(Math.pow(bodies[1].x - bodies[0].x, 2) + Math.pow(bodies[1].y - bodies[0].y, 2)),
                d13: Math.sqrt(Math.pow(bodies[2].x - bodies[0].x, 2) + Math.pow(bodies[2].y - bodies[0].y, 2)),
                d23: Math.sqrt(Math.pow(bodies[2].x - bodies[1].x, 2) + Math.pow(bodies[2].y - bodies[1].y, 2))
            };
        }

        // ============================================================
        // Rendering
        // ============================================================

        function resizeCanvas(canvas) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
            return { width: rect.width, height: rect.height };
        }

        function resizeAllCanvases() {
            resizeCanvas(simCanvas);
            resizeCanvas(energyCanvas);
            resizeCanvas(distanceCanvas);
            render();
        }

        function drawSimulation() {
            const { width, height } = resizeCanvas(simCanvas);
            const ctx = simCtx;

            // Background with subtle gradient
            const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
            gradient.addColorStop(0, '#1e1e3f');
            gradient.addColorStop(1, '#0d0d1a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Calculate view bounds
            let minX = -3, maxX = 3, minY = -3, maxY = 3;

            // Adjust view to fit all bodies
            for (const b of bodies) {
                minX = Math.min(minX, b.x - 1);
                maxX = Math.max(maxX, b.x + 1);
                minY = Math.min(minY, b.y - 1);
                maxY = Math.max(maxY, b.y + 1);
            }

            // Keep aspect ratio
            const rangeX = maxX - minX;
            const rangeY = maxY - minY;
            const aspect = width / height;

            if (rangeX / rangeY > aspect) {
                const mid = (minY + maxY) / 2;
                const newRange = rangeX / aspect;
                minY = mid - newRange / 2;
                maxY = mid + newRange / 2;
            } else {
                const mid = (minX + maxX) / 2;
                const newRange = rangeY * aspect;
                minX = mid - newRange / 2;
                maxX = mid + newRange / 2;
            }

            // Center of mass adjustment
            if (params.centerMass) {
                const com = calculateCenterOfMass(bodies);
                const offsetX = com.x;
                const offsetY = com.y;
                minX -= offsetX;
                maxX -= offsetX;
                minY -= offsetY;
                maxY -= offsetY;
            }

            function toScreen(x, y) {
                const sx = ((x - minX) / (maxX - minX)) * width;
                const sy = height - ((y - minY) / (maxY - minY)) * height;
                return { sx, sy };
            }

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridStep = Math.pow(10, Math.floor(Math.log10(maxX - minX)));

            for (let x = Math.floor(minX / gridStep) * gridStep; x <= maxX; x += gridStep) {
                const { sx } = toScreen(x, 0);
                ctx.beginPath();
                ctx.moveTo(sx, 0);
                ctx.lineTo(sx, height);
                ctx.stroke();
            }
            for (let y = Math.floor(minY / gridStep) * gridStep; y <= maxY; y += gridStep) {
                const { sy } = toScreen(0, y);
                ctx.beginPath();
                ctx.moveTo(0, sy);
                ctx.lineTo(width, sy);
                ctx.stroke();
            }

            // Draw trails
            if (params.showTrails) {
                const trailColors = [COLORS.trail1, COLORS.trail2, COLORS.trail3];
                for (let i = 0; i < 3; i++) {
                    if (trails[i].length > 1) {
                        ctx.beginPath();
                        const offset = params.centerMass ? calculateCenterOfMass(bodies) : { x: 0, y: 0 };
                        for (let j = 0; j < trails[i].length; j++) {
                            const p = trails[i][j];
                            const { sx, sy } = toScreen(p.x - (params.centerMass ? offset.x : 0),
                                                         p.y - (params.centerMass ? offset.y : 0));
                            if (j === 0) ctx.moveTo(sx, sy);
                            else ctx.lineTo(sx, sy);
                        }
                        ctx.strokeStyle = trailColors[i];
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }

            // Draw bodies
            const bodyColors = [COLORS.body1, COLORS.body2, COLORS.body3];
            const comOffset = params.centerMass ? calculateCenterOfMass(bodies) : { x: 0, y: 0 };

            for (let i = 0; i < bodies.length; i++) {
                const b = bodies[i];
                const { sx, sy } = toScreen(b.x - comOffset.x, b.y - comOffset.y);

                // Draw velocity vector
                if (params.showVectors) {
                    const velScale = 50;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx + b.vx * velScale, sy - b.vy * velScale);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Arrow head
                    const angle = Math.atan2(-b.vy, b.vx);
                    ctx.beginPath();
                    ctx.moveTo(sx + b.vx * velScale, sy - b.vy * velScale);
                    ctx.lineTo(sx + b.vx * velScale - 8 * Math.cos(angle - 0.3),
                              sy - b.vy * velScale + 8 * Math.sin(angle - 0.3));
                    ctx.lineTo(sx + b.vx * velScale - 8 * Math.cos(angle + 0.3),
                              sy - b.vy * velScale + 8 * Math.sin(angle + 0.3));
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fill();
                }

                // Draw body with glow effect
                const radius = 8 + Math.sqrt(b.m) * 6;

                // Glow
                const glow = ctx.createRadialGradient(sx, sy, 0, sx, sy, radius * 2);
                glow.addColorStop(0, bodyColors[i]);
                glow.addColorStop(0.5, bodyColors[i].replace(')', ', 0.3)').replace('rgb', 'rgba'));
                glow.addColorStop(1, 'transparent');
                ctx.beginPath();
                ctx.arc(sx, sy, radius * 2, 0, Math.PI * 2);
                ctx.fillStyle = glow;
                ctx.fill();

                // Body
                ctx.beginPath();
                ctx.arc(sx, sy, radius, 0, Math.PI * 2);
                ctx.fillStyle = bodyColors[i];
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw center of mass marker
            if (params.centerMass) {
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, 4, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
            }
        }

        function drawEnergyGraph() {
            const { width, height } = resizeCanvas(energyCanvas);
            const ctx = energyCtx;

            ctx.fillStyle = COLORS.graphBg;
            ctx.fillRect(0, 0, width, height);

            const pad = { left: 50, right: 10, top: 15, bottom: 25 };
            const w = width - pad.left - pad.right;
            const h = height - pad.top - pad.bottom;

            if (energyHistory.length < 2) return;

            // Find energy range
            let minE = Infinity, maxE = -Infinity;
            for (const e of energyHistory) {
                minE = Math.min(minE, e.PE, e.KE, e.total);
                maxE = Math.max(maxE, e.PE, e.KE, e.total);
            }
            const range = maxE - minE || 1;
            const margin = range * 0.1;
            minE -= margin;
            maxE += margin;

            // Draw grid
            ctx.strokeStyle = COLORS.grid;
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = pad.top + (h / 4) * i;
                ctx.beginPath();
                ctx.moveTo(pad.left, y);
                ctx.lineTo(width - pad.right, y);
                ctx.stroke();
            }

            // Y-axis labels
            ctx.fillStyle = COLORS.label;
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(maxE.toFixed(2), pad.left - 5, pad.top + 4);
            ctx.fillText(minE.toFixed(2), pad.left - 5, height - pad.bottom + 4);

            // Legend
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = COLORS.ke;
            ctx.fillText('KE', pad.left + 5, pad.top + 12);
            ctx.fillStyle = COLORS.pe;
            ctx.fillText('PE', pad.left + 30, pad.top + 12);
            ctx.fillStyle = COLORS.total;
            ctx.fillText('Total', pad.left + 55, pad.top + 12);

            function drawLine(key, color) {
                ctx.beginPath();
                for (let i = 0; i < energyHistory.length; i++) {
                    const x = pad.left + (i / GRAPH_HISTORY) * w;
                    const y = pad.top + h - ((energyHistory[i][key] - minE) / (maxE - minE)) * h;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            drawLine('KE', COLORS.ke);
            drawLine('PE', COLORS.pe);
            drawLine('total', COLORS.total);
        }

        function drawDistanceGraph() {
            const { width, height } = resizeCanvas(distanceCanvas);
            const ctx = distanceCtx;

            ctx.fillStyle = COLORS.graphBg;
            ctx.fillRect(0, 0, width, height);

            const pad = { left: 50, right: 10, top: 15, bottom: 25 };
            const w = width - pad.left - pad.right;
            const h = height - pad.top - pad.bottom;

            if (distanceHistory.length < 2) return;

            // Find distance range
            let maxD = 0;
            for (const d of distanceHistory) {
                maxD = Math.max(maxD, d.d12, d.d13, d.d23);
            }
            maxD = maxD * 1.1 || 1;

            // Draw grid
            ctx.strokeStyle = COLORS.grid;
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = pad.top + (h / 4) * i;
                ctx.beginPath();
                ctx.moveTo(pad.left, y);
                ctx.lineTo(width - pad.right, y);
                ctx.stroke();
            }

            // Y-axis labels
            ctx.fillStyle = COLORS.label;
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(maxD.toFixed(2), pad.left - 5, pad.top + 4);
            ctx.fillText('0', pad.left - 5, height - pad.bottom + 4);

            // Legend
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#f39c12';
            ctx.fillText('1-2', pad.left + 5, pad.top + 12);
            ctx.fillStyle = '#9b59b6';
            ctx.fillText('1-3', pad.left + 30, pad.top + 12);
            ctx.fillStyle = '#1abc9c';
            ctx.fillText('2-3', pad.left + 55, pad.top + 12);

            function drawLine(key, color) {
                ctx.beginPath();
                for (let i = 0; i < distanceHistory.length; i++) {
                    const x = pad.left + (i / GRAPH_HISTORY) * w;
                    const y = pad.top + h - (distanceHistory[i][key] / maxD) * h;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            drawLine('d12', '#f39c12');
            drawLine('d13', '#9b59b6');
            drawLine('d23', '#1abc9c');
        }

        function updateStats() {
            const energy = calculateEnergy(bodies);
            const momentum = calculateMomentum(bodies);

            document.getElementById('stat-time').textContent = time.toFixed(2);
            document.getElementById('stat-ke').textContent = energy.KE.toFixed(4);
            document.getElementById('stat-pe').textContent = energy.PE.toFixed(4);
            document.getElementById('stat-total').textContent = energy.total.toFixed(4);
            document.getElementById('stat-momentum').textContent =
                momentum.px.toFixed(4) + ', ' + momentum.py.toFixed(4);
        }

        function render() {
            drawSimulation();
            drawEnergyGraph();
            drawDistanceGraph();
            updateStats();
        }

        // ============================================================
        // Simulation Loop
        // ============================================================

        function step() {
            const stepsPerFrame = Math.round(16 * params.speed / (params.dt * 1000));

            for (let i = 0; i < stepsPerFrame; i++) {
                bodies = rk4Step(bodies, params.dt);
                time += params.dt;

                // Update trails (less frequently for performance)
                if (i % 5 === 0) {
                    for (let j = 0; j < bodies.length; j++) {
                        trails[j].push({ x: bodies[j].x, y: bodies[j].y });
                        if (trails[j].length > params.trailLength) trails[j].shift();
                    }
                }
            }

            // Update history for graphs
            const energy = calculateEnergy(bodies);
            energyHistory.push(energy);
            if (energyHistory.length > GRAPH_HISTORY) energyHistory.shift();

            const distances = calculateDistances(bodies);
            distanceHistory.push(distances);
            if (distanceHistory.length > GRAPH_HISTORY) distanceHistory.shift();

            render();

            if (running) {
                animationId = requestAnimationFrame(step);
            }
        }

        function start() {
            if (!running) {
                running = true;
                startBtn.textContent = 'Pause';
                step();
            } else {
                running = false;
                startBtn.textContent = 'Start';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }
        }

        function reset() {
            running = false;
            startBtn.textContent = 'Start';
            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            bodies = JSON.parse(JSON.stringify(initialBodies));
            time = 0;
            trails = [[], [], []];
            energyHistory = [];
            distanceHistory = [];

            render();
        }

        function applyPreset(name) {
            const preset = PRESETS[name];
            if (!preset) return;

            initialBodies = JSON.parse(JSON.stringify(preset.bodies));
            params.dt = preset.dt;
            document.getElementById('dt').value = preset.dt;
            document.getElementById('dt-val').textContent = preset.dt.toFixed(4);

            // Update mass sliders
            for (let i = 0; i < 3; i++) {
                const slider = document.getElementById('m' + (i + 1));
                const display = document.getElementById('m' + (i + 1) + '-val');
                slider.value = preset.bodies[i].m;
                display.textContent = preset.bodies[i].m.toFixed(1);
            }

            reset();
        }

        // ============================================================
        // Controls
        // ============================================================

        function setupSlider(id, callback, displayId, decimals = 1) {
            const slider = document.getElementById(id);
            const display = document.getElementById(displayId);

            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                display.textContent = value.toFixed(decimals);
                callback(value);
            });
        }

        setupSlider('dt', v => params.dt = v, 'dt-val', 4);
        setupSlider('speed', v => params.speed = v, 'speed-val', 1);
        setupSlider('trail', v => params.trailLength = v, 'trail-val', 0);

        setupSlider('m1', v => {
            initialBodies[0].m = v;
            if (!running) { bodies[0].m = v; render(); }
        }, 'm1-val');
        setupSlider('m2', v => {
            initialBodies[1].m = v;
            if (!running) { bodies[1].m = v; render(); }
        }, 'm2-val');
        setupSlider('m3', v => {
            initialBodies[2].m = v;
            if (!running) { bodies[2].m = v; render(); }
        }, 'm3-val');

        document.getElementById('show-trails').addEventListener('change', e => {
            params.showTrails = e.target.checked;
            render();
        });

        document.getElementById('show-vectors').addEventListener('change', e => {
            params.showVectors = e.target.checked;
            render();
        });

        document.getElementById('center-mass').addEventListener('change', e => {
            params.centerMass = e.target.checked;
            render();
        });

        startBtn.addEventListener('click', start);
        resetBtn.addEventListener('click', reset);

        document.getElementById('preset-figure8').addEventListener('click', () => applyPreset('figure8'));
        document.getElementById('preset-lagrange').addEventListener('click', () => applyPreset('lagrange'));
        document.getElementById('preset-binary').addEventListener('click', () => applyPreset('binary'));
        document.getElementById('preset-chaos').addEventListener('click', () => applyPreset('chaos'));

        window.addEventListener('resize', resizeAllCanvases);

        // Initialize with Figure-8
        applyPreset('figure8');

    })();
    </script>
</body>
</html>
